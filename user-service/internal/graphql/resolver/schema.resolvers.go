package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"math/rand"
	"time"
	"user-service/internal/graphql/generated"
	"user-service/internal/graphql/model"
	"user-service/pkg/jwt"
	"user-service/pkg/logger"

	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.UserMutationResponse, error) {
	if err := r.Validate.Struct(input); err != nil {
		message := "Validation failed"
		errMsg := err.Error()
		logger.Error("Validation error", err)
		return &model.UserMutationResponse{
			Code:    "400",
			Success: false,
			Message: &message,
			Errors:  []*string{&errMsg},
		}, nil
	}

	// Hash the password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		logger.Error("Failed to hash password", err)
		message := "Failed to hash password"
		return &model.UserMutationResponse{
			Code:    "500",
			Success: false,
			Message: &message,
			Errors:  []*string{&message},
		}, nil
	}
	input.Password = string(hashedPassword)

	exists, err := r.Repository.IsExistingEmail(input.Email)
	if err != nil {
		logger.Error("Database error while checking existing email", err)
		message := "Database error"
		return &model.UserMutationResponse{
			Code:    "500",
			Success: false,
			Message: &message,
			Errors:  []*string{&message},
		}, nil
	}

	if exists {
		message := "Email already exists"
		return &model.UserMutationResponse{
			Code:    "400",
			Success: false,
			Message: &message,
			Errors:  []*string{&message},
		}, nil
	}

	// Create user in database
	resUser, err := r.Repository.CreateUser(&input)
	if err != nil {
		logger.Error("Failed to create user", err)
		message := "Failed to create user"
		return &model.UserMutationResponse{
			Code:    "500",
			Success: false,
			Message: &message,
			Errors:  []*string{&message},
		}, nil
	}

	message := "User created successfully"
	return &model.UserMutationResponse{
		Code:    "201",
		Success: true,
		Message: &message,
		Errors:  nil,
		User:    &resUser,
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, userID string, username string, email string) (*model.UserMutationResponse, error) {
	modelUser := &model.User{
		UserID:   userID,
		Username: username,
		Email:    email,
	}

	user, err := r.Repository.UpdateUser(modelUser)
	if err != nil {
		logger.Error("Failed to update user", err)
		message := "Failed to update user"
		return &model.UserMutationResponse{
			Code:    "500",
			Success: false,
			Message: &message,
			Errors:  []*string{&message},
		}, nil
	}

	message := "User updated successfully"
	return &model.UserMutationResponse{
		Code:    "200",
		Success: true,
		Message: &message,
		User:    &user,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.UserInput) (*model.AuthMutationResponse, error) {
	email := input.Email
	password := input.Password

	// Find the user by email
	user, userPass, err := r.Repository.GetUserPasswordByEmail(email)
	if err != nil {
		if err.Error() == gorm.ErrRecordNotFound.Error() {
			logger.Error("User not found", err)
			message := "Invalid email or password"
			return &model.AuthMutationResponse{
				Code:    "401",
				Success: false,
				Message: message,
				Errors:  []*string{&message},
			}, nil
		}
		logger.Error("Database error while fetching user", err)
		message := "Database error"
		return &model.AuthMutationResponse{
			Code:    "500",
			Success: false,
			Message: message,
			Errors:  []*string{&message},
		}, nil
	}

	// Compare the provided password with the stored hashed password
	if err := bcrypt.CompareHashAndPassword([]byte(userPass), []byte(password)); err != nil {
		logger.Error("Invalid password", err)
		message := "Invalid email or password"
		return &model.AuthMutationResponse{
			Code:    "401",
			Success: false,
			Message: message,
			Errors:  []*string{&message},
		}, nil
	}

	accessToken, err := jwt.CreateAccessToken(user.UserID)
	if err != nil {
		logger.Error("Failed to create access token", err)
		message := "Failed to create access token"
		return &model.AuthMutationResponse{
			Code:    "500",
			Success: false,
			Message: message,
			Errors:  []*string{&message},
		}, nil
	}

	refreshToken, err := jwt.CreateRefreshToken(user.UserID)
	if err != nil {
		logger.Error("Failed to create refresh token", err)
		message := "Failed to create refresh token"
		return &model.AuthMutationResponse{
			Code:    "500",
			Success: false,
			Message: message,
			Errors:  []*string{&message},
		}, nil
	}

	// Generate token logic would go here
	// For now, return a successful response
	message := "Login successful"
	return &model.AuthMutationResponse{
		Code:         "200",
		Success:      true,
		Message:      message,
		User:         user,
		AccessToken:  &accessToken,
		RefreshToken: &refreshToken,
	}, nil
}

// RenewToken is the resolver for the renewToken field.
func (r *mutationResolver) RenewToken(ctx context.Context, refreshToken string) (*model.AuthMutationResponse, error) {
	accessToken, refreshToken, err := jwt.RefreshTokens(refreshToken)
	if err != nil {
		logger.Error("Failed to renew tokens", err)
		message := "Failed to renew tokens"
		return &model.AuthMutationResponse{
			Code:    "500",
			Success: false,
			Message: message,
			Errors:  []*string{&message},
		}, nil
	}

	return &model.AuthMutationResponse{
		Code:         "200",
		Success:      true,
		Message:      "Token renewed successfully",
		AccessToken:  &accessToken,
		RefreshToken: &refreshToken,
	}, nil
}

// AssignRole is the resolver for the assignRole field.
func (r *mutationResolver) AssignRole(ctx context.Context, userID string, role model.UserType) (*model.UserMutationResponse, error) {
	user, err := r.Repository.UpdateUser(&model.User{
		UserID: userID,
		Role:   role,
	})
	if err != nil {
		logger.Error("Failed to assign role", err)
		message := "Failed to assign role"
		return &model.UserMutationResponse{
			Code:    "500",
			Success: false,
			Message: &message,
			Errors:  []*string{&message},
		}, nil
	}

	// Nếu thành công
	message := "Role assigned successfully"
	return &model.UserMutationResponse{
		Code:    "200",
		Success: true,
		Message: &message,
		User:    &user,
	}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, role *model.UserType, userIds []string) (*model.UsersQueryRespone, error) {
	users, err := r.Repository.QueryUsers(role, userIds)
	if err != nil {
		logger.Error("Failed to query users", err)
		return nil, fmt.Errorf("failed to query users: %w", err)
	}

	response := model.UsersQueryRespone{
		Users:   users,
		Code:    "200",
		Success: true,
		Message: "Users fetched successfully",
		Errors:  nil,
	}

	return &response, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, userID string) (*model.UserQueryResponse, error) {
	user, err := r.Repository.GetUserByID(userID)
	if err != nil {
		if err.Error() == gorm.ErrRecordNotFound.Error() {
			message := "User not found"
			return &model.UserQueryResponse{
				Code:    "404",
				Success: false,
				Message: message,
				User:    nil,
			}, nil
		}
		logger.Error("Failed to fetch user", err)
		return nil, fmt.Errorf("failed to fetch user: %w", err)
	}

	return &model.UserQueryResponse{
		Code:    "200",
		Success: true,
		Message: "User fetched successfully",
		User:    user,
	}, nil
}

// ParseToken is the resolver for the parseToken field.
func (r *queryResolver) ParseToken(ctx context.Context, accessToken string) (*model.UserQueryResponse, error) {
	userID, err := jwt.ValidateToken(accessToken, true)
	if err != nil {
		logger.Error("Failed to parse token", err)
		return nil, fmt.Errorf("failed to parse token: %w", err)
	}

	user, err := r.Repository.GetUserByID(userID)
	if err != nil {
		message := "User not found"
		return &model.UserQueryResponse{
			Code:    "404",
			Success: false,
			Message: message,
			User:    nil,
		}, nil
	}

	return &model.UserQueryResponse{
		Code:    "200",
		Success: true,
		Message: "User fetched successfully",
		User:    user,
	}, nil
}

// Ping is the resolver for the ping field.
func (r *queryResolver) Ping(ctx context.Context) (model.QueryRespone, error) {
	rand.Seed(time.Now().UnixNano())

	// 30% chance to return a 500 error
	if rand.Float32() < 0.8 {
		errMsg := "Random server error occurred"
		logger.Error(errMsg, fmt.Errorf("random failure"))
		time.Sleep(100 * time.Millisecond) // Giả lập thời gian xử lý

		// Trả về một lỗi Go đơn giản
		return nil, fmt.Errorf("internal server error")
	}

	// Normal success response
	return model.UserQueryResponse{
		Code:    "200",
		Success: true,
		Message: "Pong! Service is up and running",
	}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
