package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"user-service/internal/database"
	"user-service/internal/graphql/generated"
	"user-service/internal/graphql/model"
	"user-service/internal/models"
	"user-service/pkg/jwt"
	"user-service/pkg/logger"

	"golang.org/x/crypto/bcrypt"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.UserMutationResponse, error) {
	if err := r.Validate.Struct(input); err != nil {
		message := "Validation failed"
		errMsg := err.Error()
		logger.Error("Validation error", err)
		return &model.UserMutationResponse{
			Code:    "400",
			Success: false,
			Message: &message,
			Errors:  []*string{&errMsg},
		}, nil
	}

	// Hash the password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		logger.Error("Failed to hash password", err)
		message := "Failed to hash password"
		return &model.UserMutationResponse{
			Code:    "500",
			Success: false,
			Message: &message,
			Errors:  []*string{&message},
		}, nil
	}

	user := &models.User{
		Username: input.Username,
		Email:    input.Email,
		Password: string(hashedPassword),
		Role:     models.UserType(input.Role),
	}

	// Check if email already exists more efficiently using a count query
	var count int64
	if err := database.DB.Model(&models.User{}).Where("email = ?", input.Email).Count(&count).Error; err != nil {
		logger.Error("Database error checking email", err)
		message := "Database error"
		return &model.UserMutationResponse{
			Code:    "500",
			Success: false,
			Message: &message,
			Errors:  []*string{&message},
		}, nil
	}

	if count > 0 {
		logger.Error("Email already exists", err)
		message := "Email already exists"
		return &model.UserMutationResponse{
			Code:    "400",
			Success: false,
			Message: &message,
			Errors:  []*string{&message},
		}, nil
	}

	// Create user in database
	if err := database.DB.Create(user).Error; err != nil {
		logger.Error("Failed to create user", err)
		message := "Failed to create user"
		return &model.UserMutationResponse{
			Code:    "500",
			Success: false,
			Message: &message,
			Errors:  []*string{&message},
		}, nil
	}

	message := "User created successfully"
	return &model.UserMutationResponse{
		Code:    "200",
		Success: true,
		Message: &message,
		Errors:  nil,
		User: &model.User{
			UserID:   user.ID,
			Username: user.Username,
			Email:    user.Email,
			Role:     model.UserType(user.Role),
		},
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, userID string, username string, email string) (*model.UserMutationResponse, error) {
	user := &models.User{
		ID:       userID,
		Username: username,
		Email:    email,
	}

	if err := database.DB.Save(user).Error; err != nil {
		logger.Error("Failed to update user", err)
		message := "Failed to update user"
		return &model.UserMutationResponse{
			Code:    "500",
			Success: false,
			Message: &message,
			Errors:  []*string{&message},
		}, nil
	}

	message := "User updated successfully"
	return &model.UserMutationResponse{
		Code:    "200",
		Success: true,
		Message: &message,
		User: &model.User{
			UserID:   user.ID,
			Username: user.Username,
			Email:    user.Email,
			Role:     model.UserType(user.Role),
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.UserInput) (*model.AuthMutationResponse, error) {
	email := input.Email
	password := input.Password

	// Find the user by email
	var user models.User
	if err := database.DB.Where("email = ?", email).First(&user).Error; err != nil {
		logger.Error("User not found", err)
		message := "Invalid email or password"
		return &model.AuthMutationResponse{
			Code:    "401",
			Success: false,
			Message: message,
			Errors:  []*string{&message},
		}, nil
	}

	// Compare the provided password with the stored hashed password
	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)); err != nil {
		logger.Error("Invalid password", err)
		message := "Invalid email or password"
		return &model.AuthMutationResponse{
			Code:    "401",
			Success: false,
			Message: message,
			Errors:  []*string{&message},
		}, nil
	}

	accessToken, err := jwt.CreateAccessToken(user.ID)
	if err != nil {
		logger.Error("Failed to create access token", err)
		message := "Failed to create access token"
		return &model.AuthMutationResponse{
			Code:    "500",
			Success: false,
			Message: message,
			Errors:  []*string{&message},
		}, nil
	}

	refreshToken, err := jwt.CreateRefreshToken(user.ID)
	if err != nil {
		logger.Error("Failed to create refresh token", err)
		message := "Failed to create refresh token"
		return &model.AuthMutationResponse{
			Code:    "500",
			Success: false,
			Message: message,
			Errors:  []*string{&message},
		}, nil
	}

	// Generate token logic would go here
	// For now, return a successful response
	message := "Login successful"
	return &model.AuthMutationResponse{
		Code:    "200",
		Success: true,
		Message: message,
		User: &model.User{
			UserID:   user.ID,
			Username: user.Username,
			Email:    user.Email,
			Role:     model.UserType(user.Role),
		},
		AccessToken:  &accessToken,
		RefreshToken: &refreshToken,
	}, nil
}

// RenewToken is the resolver for the renewToken field.
func (r *mutationResolver) RenewToken(ctx context.Context, refreshToken string) (*model.AuthMutationResponse, error) {
	accessToken, refreshToken, err := jwt.RefreshTokens(refreshToken)
	if err != nil {
		logger.Error("Failed to renew tokens", err)
		message := "Failed to renew tokens"
		return &model.AuthMutationResponse{
			Code:    "500",
			Success: false,
			Message: message,
			Errors:  []*string{&message},
		}, nil
	}

	return &model.AuthMutationResponse{
		Code:         "200",
		Success:      true,
		Message:      "Token renewed successfully",
		AccessToken:  &accessToken,
		RefreshToken: &refreshToken,
	}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, role model.UserType) ([]*model.User, error) {
	var users []models.User
	query := database.DB.Model(&models.User{})

	if err := query.Find(&users).Error; err != nil {
		logger.Error("Failed to fetch users", err)
		return nil, fmt.Errorf("failed to fetch users: %w", err)
	}

	var result []*model.User
	for _, user := range users {
		result = append(result, &model.User{
			UserID:   user.ID,
			Username: user.Username,
			Email:    user.Email,
			Role:     model.UserType(user.Role),
		})
	}

	return result, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, userID string) (*model.User, error) {
	var user models.User
	if err := database.DB.First(&user, "id = ?", userID).Error; err != nil {
		logger.Error("User not found", err)
		return nil, fmt.Errorf("user not found: %w", err)
	}

	return &model.User{
		UserID:   user.ID,
		Username: user.Username,
		Email:    user.Email,
		Role:     model.UserType(user.Role),
	}, nil
}

// ParseToken is the resolver for the parseToken field.
func (r *queryResolver) ParseToken(ctx context.Context, accessToken string) (*model.User, error) {
	userID, err := jwt.ValidateToken(accessToken, true)
	if err != nil {
		logger.Error("Failed to parse token", err)
		return nil, fmt.Errorf("failed to parse token: %w", err)
	}

	var user models.User
	if err := database.DB.First(&user, "id = ?", userID).Error; err != nil {
		logger.Error("User not found", err)
		return nil, fmt.Errorf("user not found: %w", err)
	}

	return &model.User{
		UserID:   user.ID,
		Username: user.Username,
		Email:    user.Email,
		Role:     model.UserType(user.Role),
	}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
